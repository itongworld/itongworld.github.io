<!DOCTYPE html>
<html>

<!-- Head template -->

<head>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Description -->
    
        <meta name="description" content="欧阳童的个人博客——学习，总结，提升">
    

    <!-- Keywords -->
    
        <meta name="keywords" content="Computer Vision, Deep Learning, Machine Learning, Python, Hexo, Snow">
    

    <!--Author-->
    
        <meta name="author" content="itongworld, itongworld@gmail.com">
    

    <!-- Favicon -->
    
        <link rel="icon" href="/favicon.png" type="image/x-icon">
    


    <!-- Title -->
    
    <title>
      
        PYTHON面向对象 - 
        欧阳阳阳的个人博客
    </title>


    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/fa_css/fa.css">




    <!-- Different css styles for different templates -->
    
      <link rel="stylesheet" href="/css/post.css">
    


</head>

<body>

<!-- main content -->
<div class="post-banner">
    <div class="banner-background" style="background-size: cover;background-image: url('/img/default_post_cover.png');"></div>
</div>

<div class="post-title">
    <h1>PYTHON面向对象</h1>
    <div class="post-meta">
            <span class="meta-entity">
                
                
                <span class="meta-date">Jan 03, 2018</span>
            </span>
            <span class="meta-entity">
                <span class="meta-tags">
                    
                      <a href="/tags/PYTHON/">PYTHON</a>
                    
                      <a href="/tags/基础语法/">基础语法</a>
                    
                </span>
            </span>

    </div>
</div>


<div class="container-fluid">
    <div class="row">

        <!-- post container in the very middle -->
        <div class="col-xs-10 col-xs-offset-1 col-sm-8 col-sm-offset-2 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3">

            <!-- post container: containing content, share -->
            <div class="post-container">

                <!-- post content -->
                <div class="post-content">
                    <h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><h3 id="1-新式类与旧式类"><a href="#1-新式类与旧式类" class="headerlink" title="1. 新式类与旧式类"></a>1. 新式类与旧式类</h3><p>所谓的新式类和旧式类之间是有区别的。在Python 3.0中，旧式类的问题不用再担心，因为它们根本就不存在了。在Python 3.0中创建一个旧式类的语法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ClassName:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>若使用新式类语法，则需要在模块或者脚本开始的地方添加赋值语句<code>__metaclass__ = type</code>，或者显式继承新式类，比如<code>object</code>等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__metaclass__ = type</span><br><span class="line"></span><br><span class="line">class ClassName:</span><br><span class="line">    pass </span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">class ClassName(object):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>如果使用<code>__metaclass__ = type</code>或从object继承的方式来定义新式类，那么可以使用<code>type(s)</code>查看实例对象所属的类。<br><a id="more"></a></p>
<h2 id="属性、方法和函数"><a href="#属性、方法和函数" class="headerlink" title="属性、方法和函数"></a>属性、方法和函数</h2><h3 id="1-self"><a href="#1-self" class="headerlink" title="1. self"></a>1. self</h3><p>self参数是对于对象自身的引用，绑定方法将其第一个参数，即self参数绑定到所属的实例上而无需显式提供该参数。需要注意的是，self参数并不依赖于调用方法的方式，既可以使用<code>instance.method()</code>方式，也可以随意使用其他变量引用同一个方法，此时该变量引用绑定方法<code>instance.method</code>，也就意味着这还是会对self参数进行访问，self参数仍旧绑定到类的相同实例上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A(object):</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print self.name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a = A()</span><br><span class="line">&gt;&gt;&gt; a.name = &apos;Python&apos;</span><br><span class="line">&gt;&gt;&gt; a.say()</span><br><span class="line">Python</span><br><span class="line">&gt;&gt;&gt; b = a.name</span><br><span class="line">&gt;&gt;&gt; b()</span><br><span class="line">Python</span><br></pre></td></tr></table></figure></p>
<h3 id="2-实例属性与类属性"><a href="#2-实例属性与类属性" class="headerlink" title="2. 实例属性与类属性"></a>2. 实例属性与类属性</h3><p>由于Python是动态语言，因而可以动态地添加和修改实例属性和类属性。</p>
<p>对于每个实例对象，允许其拥有各自不同、相互独立的实例属性。而类属性是直接绑定在类上的，因而所有实例对象共享其类的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     gender = &apos;Male&apos;</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Student.gender</span><br><span class="line">&apos;Male&apos;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; s1 = Student(&quot;Bob&quot;)</span><br><span class="line">&gt;&gt;&gt; s1.gender</span><br><span class="line">&apos;Male&apos;</span><br><span class="line">&gt;&gt;&gt; s2 = Student(&quot;Mary&quot;)</span><br><span class="line">&gt;&gt;&gt; s2.gender</span><br><span class="line">&apos;Male&apos;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; Student.gender = &apos;Female&apos;</span><br><span class="line">&gt;&gt;&gt; s2.gender</span><br><span class="line">&apos;Female&apos;</span><br></pre></td></tr></table></figure></p>
<p>访问类属性可以通过调用类或调用实例对象来实现，但修改类属性只能通过调用类来实现。否则只是在实例对象上绑定了一个同名的实例属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;s1.gender = &apos;Male&apos;</span><br><span class="line">s1.gender, s2.gender, Student.gender</span><br><span class="line">(&apos;Male&apos;, &apos;Female&apos;, &apos;Female&apos;)</span><br></pre></td></tr></table></figure></p>
<p>实例对象范围内新绑定的同名实例属性会屏蔽类范围内原有的同名类属性。这与Python函数局部变量与全局变量的行为类似。</p>
<h3 id="3-实例方法与类方法"><a href="#3-实例方法与类方法" class="headerlink" title="3. 实例方法与类方法"></a>3. 实例方法与类方法</h3><p>事实上，在class中定义的实例方法也是类的一个属性，是一个绑定到实例的函数。因此可以动态地把函数绑定到实例上，Python中使用<code>types.MethodType()</code>把一个函数转换为绑定到某个实例的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     def __init__(self, name, score):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.score = score</span><br><span class="line">&gt;&gt;&gt; def studentInfo(self):</span><br><span class="line">...     print self.name + str(self.score)</span><br><span class="line">&gt;&gt;&gt; s = Student(&quot;OUYANGTONG&quot;, 99.5)</span><br><span class="line">&gt;&gt;&gt; studentInfo(s)</span><br><span class="line">OUYANGTONG99.5</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; s.getInfo = types.MethodType(studentInfo, s, Student)</span><br><span class="line">&gt;&gt;&gt; s.getInfo()</span><br><span class="line">OUYANGTONG99.5</span><br><span class="line">&gt;&gt;&gt; s.getInfo</span><br><span class="line">&lt;bound method Student.studentInfo of &lt;__main__.Student object at 0x00000000053F4828&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果只是将函数赋值给实例的某个属性，则并不能将函数转换为方法，仍需要显式提供self参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.getInfo = studentInfo</span><br><span class="line">&gt;&gt;&gt; s.getInfo</span><br><span class="line">&lt;function studentInfo at 0x00000000053FE198&gt;</span><br><span class="line">&gt;&gt;&gt; s.getInfo()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: studentInfo() takes exactly 1 argument (0 given)</span><br></pre></td></tr></table></figure></p>
<p>类方法与类属性相似，都是绑定在某个类上，而非类的实例对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Student(object):</span><br><span class="line">...     gender = &apos;Male&apos;</span><br><span class="line">...     __studentnumber = 0</span><br><span class="line">...     @classmethod</span><br><span class="line">...     def howmany(cls):</span><br><span class="line">...         return cls.__studentnumber</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         Student.__studentnumber = Student.__studentnumber + 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Student.__studentnumber</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: type object &apos;Student&apos; has no attribute &apos;__studentnumber&apos;</span><br><span class="line">&gt;&gt;&gt; Student.howmany()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; s1 = Student(&quot;Bob&quot;)</span><br><span class="line">&gt;&gt;&gt; Student.howmany()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; s2 = Student(&quot;Mary&quot;)</span><br><span class="line">&gt;&gt;&gt; Student.howmany()</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>通过<code>@classmethod</code>装饰器创建类方法，类方法的第一个参数绑定到类本身上而无需显式提供该参数。Python中类方法与静态方法的区别请参看<a href="https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner" target="_blank" rel="noopener">meaning-of-classmethod-and-staticmethod-for-beginner</a>。</p>
<h2 id="类的私有化"><a href="#类的私有化" class="headerlink" title="类的私有化"></a>类的私有化</h2><p>Python并不直接支持类的私有化，类的属性（实例属性或类属性）或方法都可以在外部进行访问。但是，可以用一些小技巧达到私有化的效果。为了将属性（实例属性或类属性）或方法变为类私有的，而在外部无法访问，只要在它的名字前面加上双下划线即可。而如果名字前后均有双下划线，则其作为Python类中的特殊属性（实例属性或类属性）或特殊方法，则可以在外部进行访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Secretive(object):</span><br><span class="line">...     def __inaccessible(self):</span><br><span class="line">...         print &quot;Bet you can&apos;t see me...&quot;</span><br><span class="line">...     def accessible(self):</span><br><span class="line">...         print &quot;The secret message is:&quot;</span><br><span class="line">...         self.__inaccessible()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Secretive()</span><br><span class="line">&gt;&gt;&gt; s.__inaccessible()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">AttributeError: &apos;Secretive&apos; object has no attribute &apos;__inaccessible&apos;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; s.accessible()</span><br><span class="line">The secret message is:</span><br><span class="line">Bet you can&apos;t see me...</span><br></pre></td></tr></table></figure></p>
<p>然而，Python并没有真正的私有化支持。在类的内部定义中，所有以双下划线开始的名字都被“翻译”成前面加上单下划线和类名的形式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Secretive._Secretive__inaccessible</span><br><span class="line">&lt;unbound method Secretive.__inaccessible&gt;</span><br><span class="line">&gt;&gt;&gt; s._Secretive__inaccessible()</span><br><span class="line">Bet you can&apos;t see me...</span><br></pre></td></tr></table></figure></p>
<p>如果不需要使用这种方法但是又不想让其他对象访问内部数据，那么可以使用单下划线。这只是一个约定俗成的习惯，但的确有实际效果。例如，前面有单下划线的名字都不会被带星号的import语句（<code>from module import *</code>）导入。</p>
<h2 id="类的命名空间"><a href="#类的命名空间" class="headerlink" title="类的命名空间"></a>类的命名空间</h2><p>定义类时，所有位于class语句中的代码都在特殊的命名空间中执行——类命名空间。这个命名空间可由类内所有成员访问。类的定义其实就是执行代码块，因此在类的定义区并不限定只能使用def语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A(object):</span><br><span class="line">...     print &quot;Class A being defined...&quot;</span><br><span class="line">...</span><br><span class="line">Class A being defined...</span><br></pre></td></tr></table></figure></p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>Python语言支持多重继承。当使用多重继承时，应当注意各个超类的继承顺序。如果一个相同名字的方法从多个超类继承，则先继承的类中的方法会重写后继承的类中的方法，使后继承的类中的同名方法不可访问。实例属性和类属性的多重访问顺序类同。 子类的同名属性或方法会重写超类的同名属性或方法。</p>
<p>如果超类们共享一个超类，那么在查找给定方法或者属性时访问超类的顺序称为MRO（Method Resolution Order）</p>
<p>Python不支持重载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Calculator(object):</span><br><span class="line">    shortname = &quot;C&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;Calculator&quot;</span><br><span class="line">        self.value = None</span><br><span class="line">    def calculate(self, expression):</span><br><span class="line">        self.value = eval(expression)</span><br><span class="line">    def talk(self):</span><br><span class="line">        print &quot;I can&apos;t talk...&quot;</span><br><span class="line"></span><br><span class="line">class Talker(object):</span><br><span class="line">    shortname = &quot;T&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;Talker&quot;</span><br><span class="line">        self.value = None</span><br><span class="line">    def calculate(self, expression):</span><br><span class="line">        print &quot;I can&apos;t calculate...&quot;</span><br><span class="line">    def talk(self):</span><br><span class="line">        print &quot;Hi, my value is&quot;, self.value</span><br><span class="line"></span><br><span class="line">class TalkingCalculator(Calculator, Talker):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">tc = TalkingCalculator()</span><br><span class="line">tc.talk() #I can&apos;t talk...</span><br><span class="line">print tc.name #Calculator</span><br><span class="line">print tc.shortname #C</span><br></pre></td></tr></table></figure></p>

                </div>

                <!-- post share -->
                <div class="post-share">
                    <div class="share-sina-weibo">
                        <a class="fa fa-weibo" href="javascript:void((function(s,d,e,r,l,p,t,z,c){var f='http://service.weibo.com/share/share.php?appkey=2241392681&searchPic=true',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else a();})(screen,document,encodeURIComponent,'','','','','',''));"></a>
                    </div>

                    <div class="share-tencent-wechat">
                        <a class="fa fa-wechat" href="javascript:void(0)" id="popup"></a>
                    </div>
                </div>
            </div><!-- end of post-container -->
        </div>


        <!-- post toc(table of content) -->
        <div class="col-xs-1 col-sm-2 col-md-2 col-lg-3">
            <div class="post-toc">
                <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#类的创建"><span class="nav-text">类的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-新式类与旧式类"><span class="nav-text">1. 新式类与旧式类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性、方法和函数"><span class="nav-text">属性、方法和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-self"><span class="nav-text">1. self</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-实例属性与类属性"><span class="nav-text">2. 实例属性与类属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-实例方法与类方法"><span class="nav-text">3. 实例方法与类方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的私有化"><span class="nav-text">类的私有化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的命名空间"><span class="nav-text">类的命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的继承"><span class="nav-text">类的继承</span></a></li></ol>
            </div>
        </div><!-- end of post toc -->

    </div><!-- end of row -->
</div><!-- end of container-fluid -->

  <!-- website footer -->

<div class="post-footer">
  <p class="footer-copyright">&copy;&nbsp;2017-2018&nbsp;itongworld</p>
  <p class="footer-poweredby">Powered by <a href="https://github.com/itongworld">Snow</a> and <a href="https://hexo.io/">Hexo</a></p>
</div>

<!-- qrcode pop-up dialog -->
<div class="dialog-modal" id="dialog-modal">
    <a href="javascript:void(0)" title="关闭" id="popup-close"><i class="fa fa-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
        <img src="https://chart.googleapis.com/chart?cht=qr&chs=200x200&choe=UTF-8&chld=L|1&chl=http://weibo.com/ttarticle/p/show?id=2309404054181588669991#_0" alt="二维码生成失败 :(" id="share-qrcode">
    </div>
</div>

<!-- global mask -->
<div class="mask" id="mask"></div>




<script src="/js/jquery.js"></script>
<script src="/js/script.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML">
</script>

<!-- <script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script> -->
<script type="text/javascript">

    $(function() {


        //index和post页面都有post-content类。blog-post下的post-content类是index页面的，post-container下的post-content类是post页面的。
        //这段代码要放在最前面设置好图片相应宽度。
        //$(".post-container .post-content p img[alt]").each(function(){
        $(".post-content p img[alt]").each(function(){

            var altstr = $(this).attr("alt");
            //alert(altstr);

            if(altstr.endsWith("-1gg")){
                $(this).addClass("gg1");
            }

            else if(altstr.endsWith("-2gg")){
                $(this).addClass("gg2");
            }

            else if(altstr.endsWith("-3gg")){
                $(this).addClass("gg3");
            }
            else{
                $(this).addClass("gg1");
                altstr += "-1gg";
                $(this).attr("alt", altstr);
            }

            //add title
            $(this).attr("title", altstr.substring(0, altstr.length-4));

        });



        //设置图片初始相应高度。
        $(".post-content p img.gg3").height($(".post-content p img.gg3").width() * 2);
        //alert("window onload"+ $(".post-content p img").width() + ", " + $(".post-content p img").height())
        //console.log($(".post-content p img").width() + ", " + $(".post-content p img").height())

        // $(window).load(function() {
        //
        //   $(".post-content p img").height($(".post-content p img").width());
        //   //alert("window onload"+ $(".post-content p img").width() + ", " + $(".post-content p img").height())
        //   console.log($(".post-content p img").width() + ", " + $(".post-content p img").height())
        //
        // });


        $(".post-content p img.gg2").height($(".post-content p img.gg2").width());
        //$(".post-content p img.gg1").height($(".post-content p img").width());

        //Gallery
        $(".blog-post .post-gallery img").height($(".blog-post .post-gallery img").width());




        //设置图片缩放相应高度。
        $(window).resize(function() {
            $(".post-content p img.gg3").height($(".post-content p img.gg3").width() * 2);
            //alert($(".post-content p img").width() + ", " + $(".post-content p img").height())
            //console.log($(".post-content p img").width() + ", " + $(".post-content p img").height())


            $(".post-content p img.gg2").height($(".post-content p img.gg2").width());
            //$(".post-content p img.gg1").height($(".post-content p img").width());

            //Gallery
            $(".blog-post .post-gallery img").height($(".blog-post .post-gallery img").width());

        });



    });


</script>




  <script type="text/javascript">
    $(function () {

        $('body').scrollspy({
            target: '.post-toc',
            offset: 10
        });

        var $win = $(window);
        var itemOffsetTop = $(".post-banner").offset().top;
        var itemOuterHeight = $(".post-banner").outerHeight();
        var winHeight = $win.height();
        $win.scroll(function () {
            var winScrollTop = $win.scrollTop();
            if(!(winScrollTop > itemOffsetTop+itemOuterHeight) && !(winScrollTop < itemOffsetTop-winHeight)) {
                // console.log('出现了');
                $(".post-toc").removeClass("f");
            } else {
                // console.log('消失了');
                $(".post-toc").addClass("f")
            }
        });

        $("#popup").click(function(){
            $("#dialog-modal").addClass("in");
            $("#mask").addClass("in");
        });

        $("#mask").click(function(){
            $("#dialog-modal").removeClass("in");
            $("#mask").removeClass("in");
        });


        $("#popup-close").click(function(){
            $("#dialog-modal").removeClass("in");
            $("#mask").removeClass("in");

        });

    });

  </script>




</body>
</html>
